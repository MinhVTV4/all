<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chemistry Lab v4.9 - Hi·ªáu ·ª©ng K·∫øt t·ªßa N√¢ng cao</title>
    
    <!-- T√≠ch h·ª£p Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- T√≠ch h·ª£p th∆∞ vi·ªán icon Lucide -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- T√≠ch h·ª£p Marked.js ƒë·ªÉ render Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

    <script>
      // C·∫•u h√¨nh m√†u s·∫Øc v√† font cho Tailwind
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
            colors: {
              'primary': '#3b82f6',
              'primary-hover': '#2563eb',
              'secondary': '#1e293b',
              'accent': '#ec4899',
            }
          }
        }
      }
    </script>

    <style>
        :root { --sidebar-width: 26rem; }
        body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        #lab-canvas { display: block; width: 100%; height: 100%; cursor: default; }
        #lab-canvas.grabbing { cursor: grabbing; }
        #lab-canvas.grab { cursor: grab; }
        #lab-canvas.drawing-mode { cursor: crosshair; }
        
        .btn { transition: all 0.2s ease-in-out; }
        .btn:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .btn:active:not(:disabled) { transform: translateY(0px); filter: brightness(0.95); }
        
        .draw-tool.active { background-color: #3b82f6; color: white; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        .modal-backdrop { background-color: rgba(15, 23, 42, 0.8); backdrop-filter: blur(8px); }
        .card {
            background-color: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 0.75rem;
            backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .tooltip {
            position: absolute;
            background-color: rgba(15, 23, 42, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #475569;
            font-size: 14px;
            pointer-events: none;
            white-space: pre-wrap;
            z-index: 1000;
            transition: opacity 0.2s;
        }
        .log-entry .equipment-label {
            font-weight: 700;
            color: #60a5fa; /* Tailwind's blue-400 */
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }
        .plan-step-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-left: 3px solid transparent;
        }
        .plan-step-item:hover { background-color: #334155; }
        .plan-step-item.selected { background-color: #3b82f6; color: white; border-left-color: #a5b4fc; }
        .plan-step-item.completed { opacity: 0.6; text-decoration: line-through; }
        .plan-step-item.completed:hover { background-color: #1e293b; }

        @media (max-width: 1024px) {
            #left-sidebar {
                position: fixed; left: 0; top: 0; height: 100%;
                transform: translateX(calc(-1 * var(--sidebar-width)));
                transition: transform 0.3s ease-in-out; z-index: 100;
            }
            #left-sidebar.open { transform: translateX(0); }
            #main-content { padding-left: 1rem; }
            #sidebar-backdrop {
                position: fixed; inset: 0;
                background-color: rgba(0,0,0,0.5); z-index: 99;
            }
        }
    </style>
</head>
<body class="bg-secondary font-sans text-slate-200 antialiased overflow-hidden">
    
    <div id="toast-container" class="fixed bottom-4 right-4 z-[2000] flex flex-col items-end gap-2"></div>

    <!-- N√∫t m·ªü Sidebar tr√™n mobile -->
    <button id="openSidebarButton" class="lg:hidden fixed top-4 left-4 z-50 p-2 bg-slate-700/80 rounded-md btn">
        <i data-lucide="menu" class="w-6 h-6 text-white"></i>
    </button>
    <div id="sidebar-backdrop" class="hidden lg:hidden"></div>

    <!-- Modal H∆∞·ªõng d·∫´n -->
    <div id="tutorialModal" class="fixed inset-0 z-[120] flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="card w-full max-w-2xl transform transition-all" role="dialog">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-white flex items-center gap-2"><i data-lucide="book-open" class="text-primary"></i> H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h3>
                    <button id="closeTutorialButton" class="p-2 rounded-full hover:bg-slate-700"><i data-lucide="x" class="w-5 h-5"></i></button>
                </div>
                <div class="text-slate-300 space-y-4 max-h-[70vh] overflow-y-auto pr-2">
                    <div>
                        <h4 class="font-semibold text-primary mb-2 flex items-center gap-2"><i data-lucide="brain-circuit" class="w-5 h-5"></i>1. T∆∞∆°ng t√°c v·ªõi AI</h4>
                        <p>Nh·∫≠p y√™u c·∫ßu b·∫±ng ng√¥n ng·ªØ t·ª± nhi√™n (v√≠ d·ª•: "Nghi√™n c·ª©u v·ªÅ ƒê·ªìng(II) Sunfat"). AI s·∫Ω tra c·ª©u v√† hi·ªÉn th·ªã m·ªôt th·∫ª th√¥ng tin tr√™n m√†n h√¨nh.</p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-primary mb-2 flex items-center gap-2"><i data-lucide="pencil-ruler" class="w-5 h-5"></i>2. V·∫Ω D·ª•ng c·ª•</h4>
                        <p>S·ª≠ d·ª•ng "B·ªô c√¥ng c·ª• v·∫Ω" ƒë·ªÉ v·∫Ω c√°c h√¨nh d·∫°ng. Sau ƒë√≥, ra l·ªánh cho AI bi·∫øn ch√∫ng th√†nh d·ª•ng c·ª•, v√≠ d·ª•: "bi·∫øn h√¨nh ch·ªØ nh·∫≠t t√¥i v·ª´a v·∫Ω th√†nh c·ªëc ch·ª©a 100ml n∆∞·ªõc".</p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-primary mb-2 flex items-center gap-2"><i data-lucide="mouse-pointer-click" class="w-5 h-5"></i>3. T∆∞∆°ng t√°c tr√™n Canvas</h4>
                        <ul class="list-disc list-inside space-y-1 pl-2">
                            <li><strong class="text-white">Di chuy·ªÉn:</strong> D√πng chu·ªôt tr√°i k√©o/th·∫£ c√°c d·ª•ng c·ª•.</li>
                            <li><strong class="text-white">Xem th√¥ng tin:</strong> Di chu·ªôt qua m·ªôt d·ª•ng c·ª• ƒë·ªÉ xem t√™n v√† h√≥a ch·∫•t b√™n trong.</li>
                            <li><strong class="text-white">R√≥t ch·∫•t l·ªèng:</strong> K√©o m·ªôt c·ªëc/·ªëng ƒëong v√† th·∫£ v√†o m·ªôt c·ªëc kh√°c ƒë·ªÉ b·∫Øt ƒë·∫ßu r√≥t.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal X√°c nh·∫≠n -->
    <div id="confirmationModal" class="fixed inset-0 z-[110] flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="card w-full max-w-md transform transition-all" role="dialog">
            <div class="p-6 text-center">
                <i data-lucide="alert-triangle" class="mx-auto h-12 w-12 text-yellow-400"></i>
                <h3 id="confirmationTitle" class="mt-4 text-xl font-bold text-white">X√°c nh·∫≠n h√†nh ƒë·ªông</h3>
                <p id="confirmationMessage" class="mt-2 text-slate-300">B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ti·∫øp t·ª•c?</p>
                <div class="mt-6 flex justify-center gap-4">
                    <button id="confirmCancelButton" class="btn w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg">H·ªßy b·ªè</button>
                    <button id="confirmActionButton" class="btn w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg">X√°c nh·∫≠n</button>
                </div>
            </div>
        </div>
    </div>

    <div class="flex h-screen">
        <!-- KHU V·ª∞C ƒêI·ªÄU KHI·ªÇN - B√äN TR√ÅI -->
        <aside id="left-sidebar" style="--sidebar-width: 26rem;" class="w-[var(--sidebar-width)] bg-slate-800/60 p-6 flex flex-col shadow-2xl border-r border-slate-700">
            <div class="flex-shrink-0 mb-6 flex justify-between items-center">
                <h1 class="text-2xl font-black text-white tracking-tighter">AI Chemistry <span class="text-primary">Lab</span></h1>
                <span class="text-xs bg-accent/80 text-white font-bold px-2 py-1 rounded-full">v4.9</span>
            </div>

            <div class="flex flex-col flex-grow overflow-y-auto pr-2 -mr-2 space-y-6">
                <!-- Card Nh·∫≠p li·ªáu ch√≠nh -->
                <div class="card p-4">
                    <label for="promptInput" class="mb-2 font-semibold text-slate-300 flex items-center gap-2"><i data-lucide="terminal" class="w-5 h-5"></i> B·∫£ng ƒëi·ªÅu khi·ªÉn</label>
                    <textarea id="promptInput" rows="4" class="w-full p-3 bg-slate-900 border border-slate-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition duration-200 text-slate-200 placeholder-slate-500 resize-none" placeholder="B·∫Øt ƒë·∫ßu b·∫±ng c√°ch 'nghi√™n c·ª©u' m·ªôt h√≥a ch·∫•t..."></textarea>
                    
                    <div class="grid grid-cols-2 gap-3 mt-4">
                        <button id="sendPromptButton" class="btn w-full bg-primary text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2">
                            <span id="buttonText">üí¨ G·ª≠i L·ªánh</span>
                            <div id="buttonSpinner" class="hidden w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                        </button>
                         <button id="startReactionButton" disabled class="btn w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-slate-600 disabled:cursor-not-allowed">
                            <span id="reactionBtnText">üí• Ph·∫£n ·ª©ng</span>
                            <div id="reactionBtnSpinner" class="hidden w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                        </button>
                        <button id="suggestionButton" class="btn w-full bg-amber-500 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2">
                            <i data-lucide="lightbulb" class="w-5 h-5"></i> Tr·ª£ l√Ω
                        </button>
                        <button id="resetButton" class="btn w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2">
                            <i data-lucide="trash-2" class="w-5 h-5"></i> D·ªçn d·∫πp
                        </button>
                    </div>
                </div>

                <!-- Card C√¥ng c·ª• v·∫Ω -->
                <div class="card p-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-semibold text-slate-300 flex items-center gap-2"><i data-lucide="pencil-ruler"></i> B·ªô c√¥ng c·ª• v·∫Ω</h3>
                        <button id="clearDrawingsButton" class="text-xs text-slate-400 hover:text-white transition flex items-center gap-1" title="X√≥a c√°c h√¨nh ƒë√£ v·∫Ω">
                            <i data-lucide="eraser" class="w-4 h-4"></i> X√≥a h√¨nh v·∫Ω
                        </button>
                    </div>
                     <div class="grid grid-cols-4 gap-2">
                         <button class="draw-tool p-3 rounded-lg bg-slate-700/50 hover:bg-slate-700 flex flex-col items-center gap-1 text-xs" data-tool="freeform" title="V·∫Ω T·ª± do"><i data-lucide="pencil" class="w-5 h-5"></i><span>T·ª± do</span></button>
                         <button class="draw-tool p-3 rounded-lg bg-slate-700/50 hover:bg-slate-700 flex flex-col items-center gap-1 text-xs" data-tool="box" title="V·∫Ω H·ªôp"><i data-lucide="square" class="w-5 h-5"></i><span>H·ªôp</span></button>
                     </div>
                </div>

                <!-- Card K·∫ø ho·∫°ch -->
                <div id="plan-display" class="card p-4" style="display: none;">
                    <h3 class="font-semibold text-slate-300 mb-3 flex items-center gap-2"><i data-lucide="list-checks" class="w-5 h-5"></i> K·∫ø ho·∫°ch Th√≠ nghi·ªám</h3>
                    <div id="plan-steps-list" class="max-h-48 overflow-y-auto space-y-2 pr-2"></div>
                </div>
            </div>
        </aside>

        <!-- KHU V·ª∞C HI·ªÇN TH·ªä CH√çNH -->
        <main id="main-content" class="flex-1 p-6 pb-20 flex flex-col gap-6 bg-secondary/80 relative lg:pl-0">
            <div id="canvas-container" class="flex-1 bg-slate-800/30 rounded-xl shadow-lg overflow-hidden relative border border-slate-700">
                <canvas id="lab-canvas"></canvas>
                <div id="tooltip" class="tooltip" style="display: none;"></div>
            </div>
            
            <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn Ph·ª• -->
            <div class="absolute top-8 right-8 card p-3 flex items-center gap-2 z-10">
                <button id="openTutorialButton" class="btn p-3 rounded-full hover:bg-slate-700 transition" title="H∆∞·ªõng d·∫´n"><i data-lucide="help-circle" class="w-6 h-6 text-slate-300"></i></button>
                <button id="openSceneManager" class="btn p-3 rounded-full hover:bg-slate-700 transition" title="Qu·∫£n l√Ω Th√≠ nghi·ªám"><i data-lucide="folder-open" class="w-6 h-6 text-slate-300"></i></button>
            </div>
        </main>
        
        <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn d∆∞·ªõi -->
        <div id="bottom-panel" class="absolute bottom-0 left-0 right-0 h-1/3 bg-slate-800/80 backdrop-blur-md p-6 flex flex-col gap-6 z-10 rounded-t-xl shadow-2xl border-t border-slate-700 transform translate-y-[calc(100%-4rem)] transition-transform duration-300 ease-in-out">
            <button id="togglePanelButton" class="absolute -top-0 left-1/2 -translate-x-1/2 transform p-3 bg-slate-700 text-white rounded-b-lg hover:bg-slate-600 transition h-16 flex flex-col items-center justify-start pt-2">
                <span class="text-xs mb-1">Nh·∫≠t K√Ω & Ph√¢n T√≠ch</span>
                <i id="toggleIcon" data-lucide="chevron-up" class="h-6 w-6 transform transition-transform"></i>
            </button>
            <div class="flex-1 flex flex-col">
                 <h2 class="text-lg font-semibold mb-2 text-slate-300 flex items-center gap-2"><i data-lucide="history" class="w-5 h-5"></i> Nh·∫≠t k√Ω H√†nh ƒë·ªông</h2>
                 <div id="action-log" class="flex-1 bg-slate-900 text-slate-300 font-mono p-4 rounded-xl shadow-inner overflow-y-auto text-sm border border-slate-700">
                    <span class="text-slate-500">Ch∆∞a c√≥ h√†nh ƒë·ªông n√†o...</span>
                 </div>
            </div>
            <div class="flex-1 flex flex-col">
                 <h2 class="text-lg font-semibold mb-2 text-slate-300 flex items-center gap-2"><i data-lucide="bar-chart-2" class="w-5 h-5"></i> Bi·ªÉu ƒë·ªì Ph√¢n t√≠ch</h2>
                 <div id="chartContainer" class="flex-1 bg-slate-900/50 p-2 rounded-xl shadow-inner border border-slate-700 flex items-center justify-center">
                     <p class="text-slate-500">T√≠nh nƒÉng bi·ªÉu ƒë·ªì s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong t∆∞∆°ng lai.</p>
                 </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Tr·ª£ l√Ω K·∫ø ho·∫°ch (Suggestion) -->
    <div id="suggestion-modal" class="fixed inset-0 z-[110] flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="card w-full max-w-2xl transform transition-all" role="dialog">
            <div class="p-6 flex flex-col max-h-[80vh]">
                <div class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h3 class="text-xl font-bold text-white flex items-center gap-2"><i data-lucide="lightbulb" class="text-primary"></i> Tr·ª£ l√Ω K·∫ø ho·∫°ch Th√≠ nghi·ªám</h3>
                    <button id="closeSuggestionModal" class="p-2 rounded-full hover:bg-slate-700"><i data-lucide="x" class="w-5 h-5"></i></button>
                </div>
                <div id="assistant-chat-history" class="flex-grow overflow-y-auto pr-2 mb-4 space-y-4">
                    <div class="assistant-chat-message assistant">Xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p b·∫°n l√™n k·∫ø ho·∫°ch cho th√≠ nghi·ªám n√†o h√¥m nay? V√≠ d·ª•: "ƒêi·ªÅu ch·∫ø b·∫°c clorua" ho·∫∑c "Pha 100ml dung d·ªãch NaOH 0.1M".</div>
                </div>
                <div id="assistant-controls" class="flex gap-3 flex-shrink-0">
                    <input type="text" id="assistant-prompt-input" class="flex-grow p-3 bg-slate-900 border border-slate-600 rounded-lg focus:ring-2 focus:ring-primary text-white" placeholder="H·ªèi v·ªÅ ph·∫£n ·ª©ng, c√°ch ƒëi·ªÅu ch·∫ø...">
                    <button id="assistant-send-button" class="btn bg-primary text-white font-bold py-2 px-4 rounded-lg">G·ª≠i</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Qu·∫£n l√Ω Th√≠ nghi·ªám -->
    <div id="sceneManagerModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="card w-full max-w-lg transform transition-all" role="dialog">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Qu·∫£n l√Ω Th√≠ nghi·ªám</h3>
                    <button id="closeSceneManager" class="p-2 rounded-full hover:bg-slate-700"><i data-lucide="x" class="w-5 h-5"></i></button>
                </div>
                <div class="mb-4">
                    <input id="sceneNameInput" type="text" class="w-full p-3 bg-slate-900 border border-slate-600 rounded-lg focus:ring-2 focus:ring-primary text-white" placeholder="Nh·∫≠p t√™n th√≠ nghi·ªám m·ªõi...">
                    <button id="saveSceneButton" class="btn w-full mt-2 bg-green-600 text-white font-bold py-2 px-4 rounded-lg">L∆∞u th√≠ nghi·ªám hi·ªán t·∫°i</button>
                </div>
                <div id="savedScenesList" class="max-h-64 overflow-y-auto space-y-2"></div>
            </div>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-ai.js";

        // --- C·∫§U H√åNH V√Ä KHAI B√ÅO ---
        const firebaseConfig = {
            apiKey: "AIzaSyDgEH2E7W-ltp0IJwYSOjjSitB7xQhI11E",
            authDomain: "engai-374f7.firebaseapp.com",
            projectId: "engai-374f7",
            storageBucket: "engai-374f7.firebasestorage.app",
            messagingSenderId: "793685525357",
            appId: "1:793685525357:web:bf74f624247165fd53d064"
        };
        
        const dom = {
            canvas: document.getElementById('lab-canvas'),
            promptInput: document.getElementById('promptInput'),
            sendPromptButton: document.getElementById('sendPromptButton'),
            buttonText: document.getElementById('buttonText'),
            buttonSpinner: document.getElementById('buttonSpinner'),
            startReactionButton: document.getElementById('startReactionButton'),
            reactionBtnText: document.getElementById('reactionBtnText'),
            reactionBtnSpinner: document.getElementById('reactionBtnSpinner'),
            suggestionButton: document.getElementById('suggestionButton'),
            resetButton: document.getElementById('resetButton'),
            actionLog: document.getElementById('action-log'),
            planDisplay: document.getElementById('plan-display'),
            planStepsList: document.getElementById('plan-steps-list'),
            tooltip: document.getElementById('tooltip'),
            openSidebarButton: document.getElementById('openSidebarButton'),
            leftSidebar: document.getElementById('left-sidebar'),
            sidebarBackdrop: document.getElementById('sidebar-backdrop'),
            bottomPanel: document.getElementById('bottom-panel'),
            togglePanelButton: document.getElementById('togglePanelButton'),
            toggleIcon: document.getElementById('toggleIcon'),
            suggestionModal: document.getElementById('suggestion-modal'),
            closeSuggestionModal: document.getElementById('closeSuggestionModal'),
            assistantChatHistory: document.getElementById('assistant-chat-history'),
            assistantPromptInput: document.getElementById('assistant-prompt-input'),
            assistantSendButton: document.getElementById('assistant-send-button'),
            confirmationModal: document.getElementById('confirmationModal'),
            confirmationTitle: document.getElementById('confirmationTitle'),
            confirmationMessage: document.getElementById('confirmationMessage'),
            confirmCancelButton: document.getElementById('confirmCancelButton'),
            confirmActionButton: document.getElementById('confirmActionButton'),
            tutorialModal: document.getElementById('tutorialModal'),
            openTutorialButton: document.getElementById('openTutorialButton'),
            closeTutorialButton: document.getElementById('closeTutorialButton'),
            sceneManagerModal: document.getElementById('sceneManagerModal'),
            openSceneManager: document.getElementById('openSceneManager'),
            closeSceneManager: document.getElementById('closeSceneManager'),
            saveSceneButton: document.getElementById('saveSceneButton'),
            sceneNameInput: document.getElementById('sceneNameInput'),
            savedScenesList: document.getElementById('savedScenesList'),
            drawTools: document.querySelectorAll('.draw-tool'),
            clearDrawingsButton: document.getElementById('clearDrawingsButton'),
        };

        let labState = { 
            equipment: [], 
            infoCards: [], 
            knownChemicals: new Set(),
            animations: []
        };
        let executorChat = null;
        const app = initializeApp(firebaseConfig);
        const ai = getAI(app, { backend: new GoogleAIBackend() });
        const ctx = dom.canvas.getContext('2d');
        
        let activeDrawTool = null;
        let isDrawing = false;
        let drawStartPoint = null;
        let currentDrawing = {};
        let finalizedDrawings = [];

        const colorNameToRGBA = {
            'colorless': { r: 173, g: 216, b: 230, a: 0.3 }, 'white': { r: 255, g: 255, b: 255, a: 0.8 },
            'blue': { r: 0, g: 100, b: 255, a: 0.5 }, 'green': { r: 0, g: 128, b: 0, a: 0.5 },
            'yellow': { r: 255, g: 255, b: 0, a: 0.5 }, 'orange': { r: 255, g: 165, b: 0, a: 0.5 },
            'red': { r: 255, g: 0, b: 0, a: 0.5 }, 'purple': { r: 128, g: 0, b: 128, a: 0.5 },
            'pink': { r: 255, g: 192, b: 203, a: 0.5 }, 'brown': { r: 139, g: 69, b: 19, a: 0.5 },
            'black': { r: 0, g: 0, b: 0, a: 0.5 }, 'yellow-brown': { r: 255, g: 165, b: 0, a: 0.5 },
            'default': { r: 128, g: 128, b: 128, a: 0.5 }
        };

        const chemicalColors = { 
            "N∆∞·ªõc c·∫•t": { r: 173, g: 216, b: 230, a: 0.5 }
        };

        const chemicalDatabase = {
            "N∆∞·ªõc c·∫•t": { name: "N∆∞·ªõc c·∫•t", formula: "H‚ÇÇO", molarMass: 18.02, state: "Ch·∫•t l·ªèng kh√¥ng m√†u" }
        };

        // --- C√ÅC H√ÄM V·∫º D·ª§NG C·ª§ V√Ä HI·ªÜU ·ª®NG ---
        function applyShadows(ctx, isDragged = false, isHighlighted = false) {
            if (isHighlighted) {
                ctx.shadowColor = 'rgba(59, 130, 246, 0.8)';
                ctx.shadowBlur = 30;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            } else {
                ctx.shadowColor = isDragged ? 'rgba(59, 130, 246, 0.5)' : 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = isDragged ? 20 : 10;
                ctx.shadowOffsetX = isDragged ? 6 : 4;
                ctx.shadowOffsetY = isDragged ? 6 : 4;
            }
        }

        function clearShadows(ctx) {
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function drawLiquid(ctx, equipment, x, y, topRadius, bottomRadius, height, liquidY, mixedColor) {
            if (equipment.fillLevel > 0) {
                const gradient = ctx.createLinearGradient(x - topRadius, liquidY, x + topRadius, liquidY);
                const rgbaMatch = mixedColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (!rgbaMatch) return;
                const [r, g, b, a] = rgbaMatch.slice(1).map(Number);
                
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${a * 0.7})`);
                gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${a})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${a * 0.7})`);
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(x - bottomRadius, y + height - 15); // Start higher for curve
                ctx.quadraticCurveTo(x, y + height + 5, x + bottomRadius, y + height - 15);
                ctx.lineTo(x + topRadius, liquidY);
                ctx.ellipse(x, liquidY, topRadius, Math.min(topRadius * 0.2, 12), 0, 0, Math.PI);
                ctx.lineTo(x - topRadius, liquidY);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a * 1.2})`;
                ctx.beginPath();
                ctx.ellipse(x, liquidY, topRadius, Math.min(topRadius * 0.2, 12), 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawBeaker(ctx, equipment) {
            applyShadows(ctx, equipment.isDragging, equipment.isHighlighted);
            const { position, fillLevel, mixedColor, contents, maxVolume } = equipment;
            const x = position.x; const y = position.y;
            const w = 120; const h = 160;
            const rimHeight = 12; 
            const baseRadius = w / 2;
            const topRadius = w / 2 + 5;
            const bottomCurveHeight = 20;

            ctx.strokeStyle = 'rgba(148, 163, 184, 0.6)'; 
            ctx.lineWidth = 2.5;

            const glassGradient = ctx.createLinearGradient(x - topRadius, y, x + topRadius, y);
            glassGradient.addColorStop(0, 'rgba(203, 213, 225, 0.1)');
            glassGradient.addColorStop(0.5, 'rgba(226, 232, 240, 0.3)');
            glassGradient.addColorStop(1, 'rgba(203, 213, 225, 0.1)');
            ctx.fillStyle = glassGradient;

            ctx.beginPath();
            ctx.moveTo(x - topRadius, y + rimHeight);
            ctx.lineTo(x - baseRadius, y + h - bottomCurveHeight);
            ctx.quadraticCurveTo(x, y + h + bottomCurveHeight, x + baseRadius, y + h - bottomCurveHeight);
            ctx.lineTo(x + topRadius, y + rimHeight);
            ctx.stroke();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + topRadius, y + rimHeight);
            ctx.ellipse(x, y + rimHeight, topRadius, rimHeight / 2, 0, 0, Math.PI, false);
            ctx.quadraticCurveTo(x - topRadius - 18, y + rimHeight / 2, x - topRadius - 10, y);
            ctx.moveTo(x + topRadius, y + rimHeight);
            ctx.quadraticCurveTo(x + topRadius + 18, y + rimHeight / 2, x + topRadius + 10, y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.ellipse(x, y + rimHeight, topRadius, rimHeight / 2, 0, Math.PI, 2 * Math.PI);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x - topRadius + 15, y + rimHeight + 10);
            ctx.quadraticCurveTo(x - topRadius + 5, y + h/2, x - baseRadius + 15, y + h - bottomCurveHeight);
            ctx.stroke();

            clearShadows(ctx);

            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1; ctx.font = '11px Inter'; ctx.textAlign = 'right'; ctx.fillStyle = '#cbd5e1';
            const liquidMaxHeight = h - rimHeight - 15 - bottomCurveHeight;
            for (let i = 1; i <= 4; i++) {
                const markHeight = y + h - bottomCurveHeight - (i * liquidMaxHeight / 4);
                const markVolume = i * maxVolume / 4;
                ctx.beginPath();
                ctx.moveTo(x + topRadius - 8, markHeight); ctx.lineTo(x + topRadius - 20, markHeight);
                ctx.stroke();
                ctx.fillText(markVolume, x + topRadius - 25, markHeight + 4);
            }
            
            const solids = contents.filter(c => c.form === 'solid');
            if (solids.length > 0) {
                const solidHeight = 10; 
                const solidY = y + h - solidHeight;
                const solidColor = chemicalColors[solids[0].name] || colorNameToRGBA['default']; 
                ctx.fillStyle = `rgba(${solidColor.r}, ${solidColor.g}, ${solidColor.b}, 1.0)`;
                ctx.beginPath();
                ctx.ellipse(x, solidY, baseRadius-5, rimHeight/2, 0, 0, 2 * Math.PI);
                ctx.fill();
            }

            if (equipment.precipitate && equipment.precipitate.particles.length > 0) {
                drawPrecipitate(ctx, equipment);
            }

            const liquidY = y + h - fillLevel;
            drawLiquid(ctx, equipment, x, y, topRadius, baseRadius, h, liquidY, mixedColor);

            ctx.fillStyle = '#e2e8f0'; ctx.font = '16px Inter'; ctx.textAlign = 'center';
            ctx.fillText(equipment.label, x, y + h + 25 + bottomCurveHeight/2);
        }


        function drawBalance(ctx, equipment) {
            applyShadows(ctx, equipment.isDragging, equipment.isHighlighted);
            const { position, chemicalOnPlate } = equipment;
            const x = position.x; const y = position.y;
            const w = 150, h = 25;
            
            ctx.fillStyle = '#475569'; ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y + h); ctx.lineTo(x + 5, y);
            ctx.lineTo(x + w - 5, y); ctx.lineTo(x + w, y + h);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = '#334155'; ctx.strokeStyle = '#475569';
            ctx.beginPath();
            ctx.ellipse(x + w - 35, y, 30, 8, 0, 0, 2 * Math.PI);
            ctx.fill(); ctx.stroke();
            clearShadows(ctx);

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(x + 15, y + 5, w - 90, h - 10);
            ctx.fillStyle = '#6ee7b7'; ctx.font = '14px "Courier New", monospace'; ctx.textAlign = 'right';
            const massText = chemicalOnPlate ? `${chemicalOnPlate.mass.toFixed(2)}g` : '0.00g';
            ctx.fillText(massText, x + w - 95, y + h - 8);
            
            if (chemicalOnPlate) {
                const chemColor = chemicalColors[chemicalOnPlate.name] || colorNameToRGBA['default'];
                ctx.fillStyle = `rgba(${chemColor.r}, ${chemColor.g}, ${chemColor.b}, 1)`;
                ctx.beginPath();
                ctx.arc(x + w - 35, y - 5, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '10px Inter'; ctx.textAlign = 'center'; ctx.fillStyle = '#e2e8f0';
                ctx.fillText(chemicalOnPlate.name, x + w - 35, y - 20);
            }
            
            ctx.fillStyle = '#e2e8f0'; ctx.font = '14px Inter'; ctx.textAlign = 'center';
            ctx.fillText(equipment.label, x + w / 2, y + h + 20);
        }

        function drawGraduatedCylinder(ctx, equipment) {
            applyShadows(ctx, equipment.isDragging, equipment.isHighlighted);
            const { position, fillLevel, mixedColor, maxVolume } = equipment;
            const x = position.x; const y = position.y;
            const w = 60; const h = 200;
            const rimHeight = 8; const baseW = 80;
            const radius = w / 2;

            ctx.fillStyle = 'rgba(71, 85, 105, 0.3)';
            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x - radius, y + rimHeight);
            ctx.lineTo(x - radius, y + h);
            ctx.lineTo(x - baseW / 2, y + h + 15);
            ctx.lineTo(x + baseW / 2, y + h + 15);
            ctx.lineTo(x + radius, y + h);
            ctx.lineTo(x + radius, y + rimHeight);
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(x, y + rimHeight, radius, rimHeight, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            clearShadows(ctx);

            const liquidY = y + h - fillLevel;
            drawLiquid(ctx, equipment, x, y, radius, radius, h, liquidY, mixedColor);

            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1; ctx.font = '10px Inter'; ctx.textAlign = 'left';
            ctx.fillStyle = '#cbd5e1';
            for (let i = 1; i <= 5; i++) {
                const markHeight = y + h - (i * (h - rimHeight - 10) / 5);
                const markVolume = i * maxVolume / 5;
                ctx.beginPath();
                ctx.moveTo(x - radius + 2, markHeight);
                ctx.lineTo(x - radius + 15, markHeight);
                ctx.stroke();
                ctx.fillText(markVolume, x - radius - 25, markHeight + 3);
            }
            
            ctx.font = '16px Inter'; ctx.textAlign = 'center';
            ctx.fillText(equipment.label, x, y + h + 35);
        }
        
        function drawInfoCard(ctx, card, index) {
            const cardWidth = 220;
            const cardHeight = 120;
            const x = 20;
            const y = 20 + index * (cardHeight + 15);

            ctx.fillStyle = 'rgba(30, 41, 59, 0.8)';
            ctx.strokeStyle = 'rgba(71, 85, 105, 0.7)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(x, y, cardWidth, cardHeight, 8);
            } else {
                ctx.rect(x, y, cardWidth, cardHeight);
            }
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(card.name, x + 15, y + 15);

            ctx.fillStyle = '#94a3b8';
            ctx.font = '14px "Courier New", monospace';
            ctx.fillText(card.formula, x + 15, y + 40);

            ctx.fillStyle = '#cbd5e1';
            ctx.font = '12px Inter';
            ctx.fillText(`KL Mol: ${card.molarMass} g/mol`, x + 15, y + 65);
            ctx.fillText(`Tr·∫°ng th√°i: ${card.state}`, x + 15, y + 85);
        }

        // --- C√ÅC H√ÄM V·∫º HI·ªÜU ·ª®NG ƒê·ªòNG ---

        function drawPrecipitate(ctx, equipment) {
            if (!equipment.precipitate || !equipment.precipitate.particles) return;
            const precipitate = equipment.precipitate;
            const beakerBottomY = equipment.position.y + 160;
            ctx.fillStyle = precipitate.color;
            precipitate.particles.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                // C·∫≠p nh·∫≠t v·ªã tr√≠ c·ªßa h·∫°t
                if (p.y < beakerBottomY - p.settledLevel) {
                    p.y += p.speed;
                }
            });
        }
        function drawStir(ctx, equipment) {
            if (!equipment.isStirring) return;
            const w = 120;
            const x = equipment.position.x; const y = equipment.position.y;
            const liquidY = y + 160 - equipment.fillLevel;
            const angle = Date.now() / 100;
            const stirX = x + Math.cos(angle) * (w/2 - 20);
            const stirY = liquidY + 40 + Math.sin(angle) * 10;
            ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(stirX, stirY);
            ctx.stroke();
        }
        function drawShake(equipment) {
            if (equipment.isShaking) {
                const originalX = equipment.originalPosition.x;
                const offsetX = Math.sin(Date.now() / 50) * 5;
                equipment.position.x = originalX + offsetX;
            } else if (equipment.originalPosition && !equipment.isDragging) {
                equipment.position.x = equipment.originalPosition.x;
            }
        }
        function drawFizzing(ctx, equipment) {
            if (!equipment.fizzing || !equipment.fizzing.particles) return;
            ctx.fillStyle = 'rgba(226, 232, 240, 0.7)';
            const particles = equipment.fizzing.particles;
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.globalAlpha = p.opacity; ctx.fill();
                ctx.globalAlpha = 1;
                p.y -= p.speed;
                p.opacity -= 0.01;
                if (p.y < p.surfaceY || p.opacity <= 0) particles.splice(i, 1);
            }
            if (particles.length < 100 && Math.random() > 0.5) {
                const h = 160;
                const liquidSurfaceY = equipment.position.y + h - equipment.fillLevel;
                const bottomY = equipment.position.y + h;
                const w = 110;
                particles.push({
                    x: equipment.position.x + (Math.random() - 0.5) * w,
                    y: bottomY - 10 - (Math.random() * 20),
                    radius: Math.random() * 2 + 1,
                    speed: Math.random() * 1.5 + 0.5,
                    opacity: 1, surfaceY: liquidSurfaceY
                });
            }
        }

        function drawFiltering(ctx, animation) {
            const { dest, precipitate, liquid, progress } = animation;
            const funnelX = dest.position.x;
            const funnelY = dest.position.y - 30;

            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(71, 85, 105, 0.4)';
            ctx.beginPath();
            ctx.moveTo(funnelX - 40, funnelY);
            ctx.lineTo(funnelX - 10, funnelY + 40);
            ctx.lineTo(funnelX + 10, funnelY + 40);
            ctx.lineTo(funnelX + 40, funnelY);
            ctx.closePath();
            ctx.stroke(); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(funnelX - 10, funnelY + 40);
            ctx.lineTo(funnelX - 5, funnelY + 70);
            ctx.lineTo(funnelX + 5, funnelY + 70);
            ctx.lineTo(funnelX + 10, funnelY + 40);
            ctx.closePath();
            ctx.stroke(); ctx.fill();

            ctx.fillStyle = '#e2e8f0';
            ctx.beginPath();
            ctx.arc(funnelX, funnelY + 5, 38, Math.PI, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();
            if (precipitate) {
                const precipitateColor = chemicalColors[precipitate.name] || colorNameToRGBA['default'];
                ctx.fillStyle = `rgba(${precipitateColor.r}, ${precipitateColor.g}, ${precipitateColor.b}, 0.9)`;
                ctx.beginPath();
                ctx.arc(funnelX, funnelY + 15, 30 * progress, Math.PI, 2 * Math.PI);
                ctx.closePath();
                ctx.fill();
            }

            if (liquid && progress < 1) {
                const liquidColor = `rgba(${liquid.color.r}, ${liquid.color.g}, ${liquid.color.b}, 0.6)`;
                ctx.strokeStyle = liquidColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(funnelX, funnelY + 70);
                ctx.lineTo(funnelX, dest.position.y + 160 - dest.fillLevel);
                ctx.stroke();
            }
        }
        
        function drawPouringStream(ctx, anim) {
            const { source, dest, progress } = anim;
            if (progress >= 1) return;

            const sourceSpout = { x: source.position.x + 60 + 15, y: source.position.y };
            const destRim = { x: dest.position.x, y: dest.position.y + 12 };
            
            const controlPoint = { x: sourceSpout.x, y: (sourceSpout.y + destRim.y) / 2 };

            ctx.beginPath();
            ctx.moveTo(sourceSpout.x, sourceSpout.y);
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, destRim.x, destRim.y);

            ctx.strokeStyle = source.mixedColor;
            ctx.lineWidth = Math.max(1, 6 * (1 - progress));
            ctx.stroke();
        }

        // --- V√íNG L·∫∂P CH√çNH V√Ä C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI ---
        
        function updateAnimations() {
            const now = Date.now();
            for (let i = labState.animations.length - 1; i >= 0; i--) {
                const anim = labState.animations[i];

                if (!anim.startTime) anim.startTime = now;
                const elapsedTime = now - anim.startTime;
                anim.progress = Math.min(elapsedTime / anim.duration, 1);

                if (anim.type === 'filtering') {
                    const sourceFillHeight = anim.source.drawableHeight || 133;
                    anim.source.fillLevel = sourceFillHeight * (1 - anim.progress);

                    const destFillHeight = anim.dest.drawableHeight || 133;
                    const finalVolume = anim.dest.contents.reduce((sum, c) => sum + (c.volume || 0), 0);
                    anim.dest.fillLevel = (finalVolume / anim.dest.maxVolume) * destFillHeight * anim.progress;

                    if (anim.progress >= 1) {
                        anim.source.contents = [];
                        anim.source.fillLevel = 0;
                        recalculateSolutionProperties(anim.dest);
                        labState.animations.splice(i, 1);
                    }
                } else if (anim.type === 'pouring') {
                    const amountToTransfer = anim.quantity * anim.progress;
                    const sourceTotalVolume = anim.initialSourceLiquids.reduce((sum, c) => sum + c.volume, 0);
                    
                    let remainingVolumeInSource = sourceTotalVolume - amountToTransfer;
                    anim.source.fillLevel = (remainingVolumeInSource / anim.source.maxVolume) * anim.source.drawableHeight;

                    let newVolumeInDest = anim.initialDestVolume + amountToTransfer;
                    anim.dest.fillLevel = (newVolumeInDest / anim.dest.maxVolume) * anim.dest.drawableHeight;

                    if (anim.progress >= 1) {
                        const chemicalsToTransfer = [];
                        const proportion = anim.quantity / sourceTotalVolume;
                        
                        anim.initialSourceLiquids.forEach(liquid => {
                            const amount = liquid.volume * proportion;
                            chemicalsToTransfer.push({ ...liquid, volume: amount });
                        });

                        anim.source.contents = anim.source.contents.filter(c => !anim.initialSourceLiquids.some(l => l.name === c.name));
                        anim.initialSourceLiquids.forEach(liquid => {
                            liquid.volume *= (1 - proportion);
                            if(liquid.volume > 0.01) anim.source.contents.push(liquid);
                        });
                        
                        anim.dest.contents.push(...chemicalsToTransfer);
                        
                        recalculateSolutionProperties(anim.source);
                        recalculateSolutionProperties(anim.dest);
                        labState.animations.splice(i, 1);
                    }
                }
            }
        }

        function drawLab() {
            const container = dom.canvas.parentElement;
            if (dom.canvas.width !== container.clientWidth || dom.canvas.height !== container.clientHeight) {
                dom.canvas.width = container.clientWidth;
                dom.canvas.height = container.clientHeight;
            }
            
            ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
            
            updateAnimations();
            updateButtonStates();

            ctx.save();
            const allDrawings = [...finalizedDrawings, ...(isDrawing ? [currentDrawing] : [])];
            allDrawings.forEach((drawing) => {
                if (drawing && drawing.type) {
                    ctx.strokeStyle = '#34d399';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    switch (drawing.type) {
                        case 'freeform':
                            if (drawing.path && drawing.path.length > 1) {
                                ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
                                for (let i = 1; i < drawing.path.length; i++) ctx.lineTo(drawing.path[i].x, drawing.path[i].y);
                            }
                            break;
                        case 'box': ctx.rect(drawing.x, drawing.y, drawing.w, drawing.h); break;
                    }
                    ctx.stroke();
                }
            });
            ctx.restore();

            labState.equipment.forEach(eq => {
                drawShake(eq);
                if (eq.type === 'beaker') {
                    drawBeaker(ctx, eq);
                    drawFizzing(ctx, eq);
                } else if (eq.type === 'balance') {
                    drawBalance(ctx, eq);
                } else if (eq.type === 'graduatedCylinder') {
                    drawGraduatedCylinder(ctx, eq);
                    drawFizzing(ctx, eq);
                }
            });
            labState.animations.forEach(anim => {
                if (anim.type === 'filtering') {
                    drawFiltering(ctx, anim);
                } else if (anim.type === 'pouring') {
                    drawPouringStream(ctx, anim);
                }
            });

            labState.infoCards.forEach((card, index) => {
                drawInfoCard(ctx, card, index);
            });

            requestAnimationFrame(drawLab);
        }

        // --- UI V√Ä T∆Ø∆†NG T√ÅC NG∆Ø·ªúI D√ôNG ---
        function renderAndActivatePlan(steps) {
            dom.planStepsList.innerHTML = '';
            steps.forEach((step, index) => {
                const li = document.createElement('li');
                li.id = `plan-step-${index}`;
                li.className = 'plan-step-item';
                li.innerHTML = `<span class="font-semibold text-primary">B∆∞·ªõc ${index + 1}:</span> ${step.description}`;
                li.dataset.prompt = step.prompt;
                li.onclick = () => {
                    dom.promptInput.value = step.prompt;
                    dom.promptInput.focus();
                    document.querySelectorAll('.plan-step-item').forEach(item => item.classList.remove('selected'));
                    li.classList.add('selected');
                };
                dom.planStepsList.appendChild(li);
            });
            dom.planDisplay.style.display = 'block';
        }

        function showToast(message, type) {
            const icons = {
                'user-request': 'üë§', 'ai-response': 'ü§ñ',
                'function-call': '‚öôÔ∏è', 'function-result': '‚úîÔ∏è',
                'system': 'üîß', 'error': '‚ùå'
            };
            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) return;
            const toast = document.createElement('div');
            toast.className = `toast ${type} p-4 rounded-lg shadow-lg text-white font-semibold flex items-center gap-3`;
            const textContent = message.replace(/<[^>]*>/g, '');
            toast.innerHTML = `<span class="text-xl">${icons[type] || 'üîî'}</span> <span>${textContent}</span>`;
            
            const typeColors = {
                'user-request': 'bg-blue-500', 'ai-response': 'bg-green-500',
                'function-call': 'bg-purple-500', 'function-result': 'bg-orange-500',
                'system': 'bg-slate-500', 'error': 'bg-red-500'
            };
            toast.classList.add(typeColors[type] || 'bg-gray-500');

            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.style.transition = 'opacity 0.5s ease';
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 500);
            }, 4500);
        }

        function logAction(type, content) {
            if (dom.actionLog.innerHTML.includes("Ch∆∞a c√≥ h√†nh ƒë·ªông n√†o")) { dom.actionLog.innerHTML = ""; }
            const icons = {
                'user-request': 'üë§', 'ai-response': 'ü§ñ',
                'function-call': '‚öôÔ∏è', 'function-result': '‚úîÔ∏è',
                'system': 'üîß', 'error': '‚ùå'
            };
            let formattedContent = content;
            labState.equipment.forEach(eq => {
                const regex = new RegExp(`'${eq.label}'|"${eq.label}"`, 'g');
                formattedContent = formattedContent.replace(regex, `<span class="equipment-label" data-label="${eq.label}">${eq.label}</span>`);
            });

            const entry = document.createElement('div');
            entry.className = `log-entry ${type} flex items-start gap-2 mb-2`;
            entry.innerHTML = `<span class="icon mt-1" title="${type}">${icons[type] || '‚Ä¢'}</span><div>${formattedContent}</div>`;
            dom.actionLog.appendChild(entry);
            dom.actionLog.scrollTop = dom.actionLog.scrollHeight;
            if (type !== 'function-call' && type !== 'function-result') {
                showToast(content, type);
            }
        }

        let draggedItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function getEquipmentAtPos(mouseX, mouseY) {
            for (let i = labState.equipment.length - 1; i >= 0; i--) {
                const eq = labState.equipment[i];
                const { x, y } = eq.position;
                let w, h;
                if (eq.type === 'beaker') { w = 120; h = 160; }
                else if (eq.type === 'balance') { w = 150; h = 45; }
                else if (eq.type === 'graduatedCylinder') { w = 80; h = 215; }
                
                if (w && h && mouseX > x - w/2 && mouseX < x + w/2 && mouseY > y && mouseY < y + h + 40) {
                    return eq;
                }
            }
            return null;
        }

        dom.canvas.addEventListener('mousedown', (e) => {
            if (activeDrawTool) { startDraw(e); return; }

            const rect = dom.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const item = getEquipmentAtPos(mouseX, mouseY);
            if (item) {
                draggedItem = item;
                draggedItem.isDragging = true;
                dragOffsetX = mouseX - item.position.x;
                dragOffsetY = mouseY - item.position.y;
                dom.canvas.classList.add('grabbing');
            }
        });

        window.addEventListener('mouseup', () => {
            if (isDrawing) { endDraw(); return; }

            if (draggedItem) {
                draggedItem.isDragging = false;
                
                const rect = dom.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const targetItem = getEquipmentAtPos(mouseX, mouseY);
                
                if (targetItem && targetItem !== draggedItem && 
                    (draggedItem.type === 'beaker' || draggedItem.type === 'graduatedCylinder') &&
                    targetItem.type === 'beaker') {
                        
                    const sourceTotalVolume = draggedItem.contents.filter(c => c.form === 'liquid').reduce((sum, c) => sum + c.volume, 0);
                    if (sourceTotalVolume > 0) {
                        availableFunctions.transferLiquid({
                            sourceId: draggedItem.label,
                            destinationId: targetItem.label,
                            quantity: sourceTotalVolume 
                        });
                    }
                }

                draggedItem.originalPosition = { ...draggedItem.position };
            }
            draggedItem = null;
            dom.canvas.classList.remove('grabbing');
            dom.canvas.classList.remove('grab');
        });

        dom.canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) { draw(e); return; }

            const rect = dom.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (draggedItem) {
                draggedItem.position.x = mouseX - dragOffsetX;
                draggedItem.position.y = mouseY - dragOffsetY;
            } else {
                const item = getEquipmentAtPos(mouseX, mouseY);
                dom.canvas.classList.toggle('grab', !!item);
                
                if (item) {
                    const liquids = item.contents.filter(c => c.form === 'liquid').map(c => `${c.name} (${(c.volume || 0).toFixed(1)}ml)`).join('\n');
                    const solids = item.contents.filter(c => c.form === 'solid').map(c => `${c.name} (${c.quantity}g)`).join('\n');
                    let content = `<strong>${item.label}</strong> (${item.type})`;
                    if (liquids) content += `\n- ${liquids}`;
                    if (solids) content += `\n- ${solids}`;
                    
                    dom.tooltip.innerHTML = content;
                    dom.tooltip.style.left = `${mouseX + 15}px`;
                    dom.tooltip.style.top = `${mouseY + 15}px`;
                    dom.tooltip.style.display = 'block';
                } else {
                    dom.tooltip.style.display = 'none';
                }
            }
        });
        
        dom.canvas.addEventListener('mouseout', () => {
             if (draggedItem) {
                draggedItem.isDragging = false;
                draggedItem.originalPosition = { ...draggedItem.position };
            }
            draggedItem = null;
            dom.canvas.classList.remove('grabbing');
            dom.canvas.classList.remove('grab');
        });

        function updateButtonStates() {
            const reactionReady = labState.equipment.some(e => e.type === 'beaker' && e.contents.filter(c => c.form === 'liquid' || c.form === 'solid').length > 1);
            dom.startReactionButton.disabled = !reactionReady;
        }
        
        // --- LOGIC C·ªêT L√ïI V√Ä C√ÅC H√ÄM C√îNG C·ª§ CHO AI ---
        function recalculateSolutionProperties(equipment) {
            if (!equipment || !equipment.contents) return;

            const liquids = equipment.contents.filter(c => c.form === 'liquid');
            const totalVolume = liquids.reduce((sum, c) => sum + (c.volume || 0), 0);

            if (totalVolume > 0) {
                let r = 0, g = 0, b = 0;
                liquids.forEach(chem => {
                    if (chem.color && typeof chem.color === 'object' && chem.volume > 0) {
                        r += (chem.color.r || 0) * chem.volume;
                        g += (chem.color.g || 0) * chem.volume;
                        b += (chem.color.b || 0) * chem.volume;
                    }
                });
                equipment.mixedColor = `rgba(${Math.round(r/totalVolume)}, ${Math.round(g/totalVolume)}, ${Math.round(b/totalVolume)}, 0.6)`;
            } else {
                equipment.mixedColor = 'rgba(0,0,0,0)';
            }

            const fillHeight = equipment.drawableHeight || 133;
            equipment.fillLevel = (totalVolume / equipment.maxVolume) * fillHeight;
        }

        const availableFunctions = {
            createEquipmentFromDrawings: ({ objects }) => {
                objects = objects || [];
                finalizedDrawings.forEach((drawing, index) => {
                    const objInfo = objects.find(o => o.drawingIndex === index);
                    if (!objInfo) return;

                    const id = `eq-${Date.now()}-${index}`;
                    let centerX, centerY;
                    if (drawing.type === 'box') {
                        centerX = drawing.x + drawing.w / 2;
                        centerY = drawing.y + drawing.h / 2;
                    } else if (drawing.type === 'freeform') {
                        let sumX = 0, sumY = 0;
                        drawing.path.forEach(p => { sumX += p.x; sumY += p.y; });
                        centerX = sumX / drawing.path.length;
                        centerY = sumY / drawing.path.length;
                    } else {
                        return;
                    }

                    const newEquipment = {
                        id, type: objInfo.type || 'beaker', label: objInfo.label,
                        position: { x: centerX, y: centerY },
                        originalPosition: { x: centerX, y: centerY },
                        contents: [], mixedColor: 'rgba(0,0,0,0)', fillLevel: 0,
                        maxVolume: objInfo.capacity || 250,
                        isStirring: false, isShaking: false, precipitate: null, fizzing: null,
                        isDragging: false, isHighlighted: false,
                        drawableHeight: 133
                    };
                    labState.equipment.push(newEquipment);
                });
                clearAllDrawings();
                return { success: true, message: `ƒê√£ t·∫°o ${objects.length} d·ª•ng c·ª• t·ª´ h√¨nh v·∫Ω.` };
            },

            addChemical: async ({ equipmentId, name, form, quantity, unit, concentration }) => {
                const equipment = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!equipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• '${equipmentId}'.` };
                
                let chemicalKeyForColor = Object.keys(chemicalColors).find(k => k.toLowerCase() === name.toLowerCase());
                if (!chemicalKeyForColor) {
                    const researchResult = await availableFunctions.researchChemical({ chemicalName: name });
                    if (!researchResult.success) {
                        return { success: false, message: `Kh√¥ng th·ªÉ t√¨m th·∫•y th√¥ng tin cho h√≥a ch·∫•t m·ªõi: ${name}` };
                    }
                    chemicalKeyForColor = researchResult.chemicalInfo.formula;
                }
                const newChemicalColor = chemicalColors[chemicalKeyForColor] || colorNameToRGBA['default'];

                if (form === 'liquid') {
                    const currentTotalVolume = equipment.contents.reduce((sum, chem) => sum + (chem.volume || 0), 0);
                    if (currentTotalVolume + quantity > equipment.maxVolume) { 
                        return { success: false, message: `D·ª•ng c·ª• s·∫Ω b·ªã tr√†n.` }; 
                    }
                    equipment.contents.push({ name, volume: quantity, color: newChemicalColor, form: 'liquid', concentration });
                    recalculateSolutionProperties(equipment);
                    return { success: true, message: `ƒê√£ th√™m ${quantity}ml ${name} ${concentration || ''} v√†o ${equipment.label}.` };
                } else if (form === 'solid') {
                    equipment.contents.push({ name, quantity, unit, form: 'solid', color: newChemicalColor });
                    recalculateSolutionProperties(equipment);
                    return { success: true, message: `ƒê√£ th√™m ${quantity}${unit} ${name} v√†o ${equipment.label}.` };
                }
                return { success: false, message: "D·∫°ng h√≥a ch·∫•t kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£." };
            },
            changeSolutionColor: ({ equipmentId, newColorName }) => {
                const equipment = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!equipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• '${equipmentId}'.` };
                const newColor = colorNameToRGBA[newColorName.toLowerCase()] || colorNameToRGBA['default'];
                
                const totalVolume = equipment.contents.reduce((sum, c) => sum + (c.volume || 0), 0);
                equipment.contents = [{
                    name: "S·∫£n ph·∫©m ph·∫£n ·ª©ng",
                    volume: totalVolume,
                    color: newColor,
                    form: 'liquid'
                }];
                recalculateSolutionProperties(equipment);
                return { success: true, message: `Dung d·ªãch trong ${equipment.label} ƒë√£ ƒë·ªïi th√†nh m√†u ${newColorName}.` };
            },
            displayChemicalInfo: ({ chemicalInfo }) => {
                if (!labState.infoCards.some(card => card.formula === chemicalInfo.formula)) {
                    labState.infoCards.push(chemicalInfo);
                }
                return { success: true, message: `ƒê√£ hi·ªÉn th·ªã th√¥ng tin cho ${chemicalInfo.name}.` };
            },
            filter_precipitate: ({ sourceId, destinationId }) => {
                const source = labState.equipment.find(e => e.label === sourceId);
                const dest = labState.equipment.find(e => e.label === destinationId);

                if (!source || source.type !== 'beaker') return { success: false, message: `Kh√¥ng t√¨m th·∫•y c·ªëc ngu·ªìn '${sourceId}'.` };
                if (!dest || dest.type !== 'beaker') return { success: false, message: `Kh√¥ng t√¨m th·∫•y c·ªëc ƒë√≠ch '${destinationId}'.` };

                const precipitate = source.contents.find(c => c.isPrecipitate);
                if (!precipitate) return { success: false, message: `Kh√¥ng t√¨m th·∫•y k·∫øt t·ªßa trong '${sourceId}'.` };

                const liquid = source.contents.find(c => c.form === 'liquid');
                if (!liquid) return { success: false, message: `Kh√¥ng c√≥ dung d·ªãch ƒë·ªÉ l·ªçc trong '${sourceId}'.` };

                labState.animations.push({
                    type: 'filtering',
                    source: source,
                    dest: dest,
                    precipitate: precipitate,
                    liquid: liquid,
                    progress: 0,
                    duration: 5000
                });

                dest.contents.push(liquid);
                source.contents = source.contents.filter(c => !c.isPrecipitate);
                
                recalculateSolutionProperties(source);
                recalculateSolutionProperties(dest);

                return { success: true, message: `B·∫Øt ƒë·∫ßu l·ªçc k·∫øt t·ªßa t·ª´ '${sourceId}' sang '${destinationId}'.` };
            },
            finalizeExperiment: ({ steps }) => {
                renderAndActivatePlan(steps);
                closeSuggestionModal();
                return { success: true, message: "K·∫ø ho·∫°ch ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ra m√†n h√¨nh ch√≠nh. H√£y th·ª±c hi·ªán t·ª´ng b∆∞·ªõc." };
            },
            getNewEquipment: ({ type, label, capacity }) => {
                const id = `eq-${Date.now()}`;
                const existingCount = labState.equipment.length;
                const position = { x: 150 + existingCount * 220, y: 200 };
                
                const newEquipment = {
                    id, type, label, position,
                    originalPosition: { ...position },
                    contents: [], mixedColor: 'rgba(0,0,0,0)', fillLevel: 0,
                    maxVolume: capacity || 250,
                    isStirring: false, isShaking: false, precipitate: null, fizzing: null,
                    isDragging: false, isHighlighted: false
                };

                if (type === 'beaker') newEquipment.drawableHeight = 133;
                else if (type === 'graduatedCylinder') newEquipment.drawableHeight = 180;
                
                labState.equipment.push(newEquipment);
                return { success: true, message: `ƒê√£ l·∫•y ra m·ªôt ${type} m·ªõi c√≥ nh√£n '${label}'.`, equipmentId: id, label: label };
            },
            measure_liquid: async ({ sourceId, destinationId, chemical_name, quantity_ml }) => {
                const source = labState.equipment.find(e => e.label === sourceId);
                const cylinder = labState.equipment.find(e => e.label === destinationId);
                
                if (!source) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• ngu·ªìn '${sourceId}'.` };
                if (!cylinder || cylinder.type !== 'graduatedCylinder') return { success: false, message: `D·ª•ng c·ª• ƒë√≠ch '${destinationId}' kh√¥ng ph·∫£i l√† ·ªëng ƒëong.` };

                const chemicalInSource = source.contents.find(c => c.name === chemical_name && c.form === 'liquid');
                if (!chemicalInSource || chemicalInSource.volume < quantity_ml) {
                    return { success: false, message: `Kh√¥ng ƒë·ªß ${quantity_ml}ml ${chemical_name} trong ${sourceId}.` };
                }
                
                chemicalInSource.volume -= quantity_ml;
                
                cylinder.contents.push({ name: chemical_name, volume: quantity_ml, color: chemicalColors[chemical_name], form: 'liquid' });

                recalculateSolutionProperties(source);
                recalculateSolutionProperties(cylinder);

                return { success: true, message: `ƒê√£ ƒëong ${quantity_ml}ml ${chemical_name} t·ª´ ${sourceId} v√†o ${destinationId}.` };
            },
            researchChemical: async ({ chemicalName }) => {
                const keyName = chemicalName.toLowerCase();
                const existingChemical = Object.keys(chemicalDatabase).find(k => k.toLowerCase() === keyName);
                if (existingChemical) {
                    labState.knownChemicals.add(existingChemical);
                    availableFunctions.displayChemicalInfo({ chemicalInfo: chemicalDatabase[existingChemical] });
                    return { success: true, chemicalInfo: chemicalDatabase[existingChemical] };
                }
                logAction('system', `<strong>APP:</strong> H√≥a ch·∫•t '${chemicalName}' kh√¥ng c√≥ trong d·ªØ li·ªáu. ƒêang t√¨m ki·∫øm...`);
                try {
                    const lookupModel = getGenerativeModel(ai, { model: "gemini-2.0-flash" });
                    const prompt = `Cung c·∫•p th√¥ng tin cho h√≥a ch·∫•t "${chemicalName}" theo ƒë·ªãnh d·∫°ng JSON sau: {"name": "T√™n ti·∫øng Vi·ªát", "formula": "C√¥ng th·ª©c h√≥a h·ªçc", "molarMass": kh·ªëi l∆∞·ª£ng mol (s·ªë), "state": "Tr·∫°ng th√°i v·∫≠t l√Ω", "colorName": "t√™n m√†u s·∫Øc c·ªßa dung d·ªãch b·∫±ng ti·∫øng Anh (v√≠ d·ª•: 'blue', 'yellow', 'colorless')"}. N·∫øu kh√¥ng t√¨m th·∫•y, tr·∫£ v·ªÅ {"success": false}.`;
                    const result = await lookupModel.generateContent(prompt);
                    const textResponse = result.response.text();
                    const jsonString = textResponse.match(/{.*}/s)[0];
                    const chemicalInfo = JSON.parse(jsonString);
                    if (chemicalInfo.success === false || !chemicalInfo.formula) {
                        throw new Error(`Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ${chemicalName}.`);
                    }
                    const newKey = chemicalInfo.formula;
                    chemicalDatabase[newKey] = chemicalInfo;
                    labState.knownChemicals.add(newKey);
                    if (!chemicalColors[newKey]) {
                         const colorName = chemicalInfo.colorName ? chemicalInfo.colorName.toLowerCase() : 'default';
                         chemicalColors[newKey] = colorNameToRGBA[colorName] || colorNameToRGBA['default'];
                    }
                    logAction('system', `<strong>APP:</strong> ƒê√£ t√¨m th·∫•y v√† th√™m '${chemicalInfo.name}' v√†o d·ªØ li·ªáu.`);
                    availableFunctions.displayChemicalInfo({ chemicalInfo });
                    return { success: true, chemicalInfo: chemicalInfo };
                } catch (e) {
                    console.error("L·ªói khi t√¨m ki·∫øm h√≥a ch·∫•t:", e);
                    logAction('error', `<strong>L·ªói:</strong> Kh√¥ng th·ªÉ t√¨m th·∫•y ho·∫∑c x·ª≠ l√Ω th√¥ng tin cho ${chemicalName}.`);
                    return { success: false, message: `Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ${chemicalName}.` };
                }
            },
            resetLab: () => {
                labState = { equipment: [], infoCards: [], knownChemicals: new Set(), animations: [] };
                clearAllDrawings();
                dom.actionLog.innerHTML = "<span class='text-slate-500'>Ch∆∞a c√≥ h√†nh ƒë·ªông n√†o...</span>";
                dom.planDisplay.style.display = 'none';
                dom.planStepsList.innerHTML = '';
                executorChat = null; 
                return { success: true, message: "Ph√≤ng th√≠ nghi·ªám ƒë√£ ƒë∆∞·ª£c d·ªçn d·∫πp." };
            },
            shake: async ({ equipmentId, duration_seconds }) => {
                const equipment = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!equipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• '${equipmentId}'.` };
                equipment.isShaking = true;
                await new Promise(resolve => setTimeout(resolve, duration_seconds * 1000));
                equipment.isShaking = false;
                return { success: true, message: `ƒê√£ l·∫Øc ƒë·ªÅu dung d·ªãch trong '${equipment.label}'.` };
            },
            // N√ÇNG C·∫§P: Hi·ªáu ·ª©ng k·∫øt t·ªßa ƒë∆∞·ª£c l√†m l·∫°i ho√†n to√†n
            showReactionEffect: async ({ effect, productName, equipmentId }) => {
                const equipment = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!equipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• '${equipmentId}'.` };
                if (effect === 'precipitate') {
                    const color = productName ? (chemicalColors[productName] || colorNameToRGBA['default']) : colorNameToRGBA['default'];
                    
                    equipment.precipitate = { particles: [], color: `rgba(${color.r}, ${color.g}, ${color.b}, 0.9)` };
                    // T·∫°o c√°c h·∫°t k·∫øt t·ªßa
                    for (let i = 0; i < 200; i++) {
                        equipment.precipitate.particles.push({
                            x: equipment.position.x + (Math.random() - 0.5) * 100,
                            y: equipment.position.y + 20 + Math.random() * 100,
                            radius: Math.random() * 1.5 + 0.5,
                            speed: Math.random() * 0.5 + 0.2,
                            settledLevel: Math.random() * 20
                        });
                    }
                    // Hi·ªáu ·ª©ng s·∫Ω di·ªÖn ra trong v√≤ng l·∫∑p v·∫Ω, kh√¥ng c·∫ßn ch·ªù ·ªü ƒë√¢y
                } else if (effect === 'fizzing') {
                    equipment.fizzing = { particles: [] };
                    setTimeout(() => {
                        equipment.fizzing = null;
                    }, 4000);
                }
                return { success: true, message: `Hi·ªáu ·ª©ng ${effect} ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã.` };
            },
            stir: async ({ equipmentId, duration_seconds }) => {
                const equipment = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!equipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• '${equipmentId}'.` };

                const solidIndex = equipment.contents.findIndex(c => c.form === 'solid');
                const liquids = equipment.contents.filter(c => c.form === 'liquid');

                if (solidIndex === -1 || liquids.length === 0) {
                    equipment.isStirring = true;
                    await new Promise(resolve => setTimeout(resolve, duration_seconds * 1000));
                    equipment.isStirring = false;
                    return { success: true, message: `ƒê√£ khu·∫•y trong '${equipment.label}', kh√¥ng c√≥ g√¨ thay ƒë·ªïi.` };
                }

                const solid = equipment.contents[solidIndex];
                const solvent = liquids.reduce((max, liq) => liq.volume > max.volume ? liq : max, liquids[0]);

                equipment.isStirring = true;
                await new Promise(resolve => setTimeout(resolve, duration_seconds * 1000));
                equipment.isStirring = false;

                equipment.contents.splice(solidIndex, 1);

                solvent.volume += solid.quantity; 
                solvent.name = `Dung d·ªãch ${solid.name}`;
                solvent.color = solid.color; 

                recalculateSolutionProperties(equipment);
                
                return { success: true, message: `ƒê√£ khu·∫•y v√† h√≤a tan ${solid.name} trong '${equipment.label}'.` };
            },
            transferLiquid: ({ sourceId, destinationId, quantity }) => {
                const source = labState.equipment.find(e => e.id === sourceId || e.label === sourceId);
                const dest = labState.equipment.find(e => e.id === destinationId || e.label === destinationId);
                if (!source || !dest) return { success: false, message: "Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• ngu·ªìn ho·∫∑c ƒë√≠ch." };
                
                const sourceLiquids = source.contents.filter(c => c.form === 'liquid');
                const sourceTotalVolume = sourceLiquids.reduce((sum, c) => sum + c.volume, 0);

                if (quantity > sourceTotalVolume) return { success: false, message: `Kh√¥ng ƒë·ªß ${quantity}ml ch·∫•t l·ªèng trong ${source.label} ƒë·ªÉ chuy·ªÉn.` };
                
                const initialDestVolume = dest.contents.filter(c => c.form === 'liquid').reduce((sum, c) => sum + c.volume, 0);

                labState.animations.push({
                    type: 'pouring',
                    source, dest, quantity,
                    progress: 0, duration: 2000,
                    initialSourceLiquids: JSON.parse(JSON.stringify(sourceLiquids)),
                    initialDestVolume: initialDestVolume
                });

                return { success: true, message: `B·∫Øt ƒë·∫ßu r√≥t ${quantity}ml t·ª´ ${source.label} sang ${dest.label}.` };
            },
            transferSolid: ({ sourceId, destinationId }) => {
                const sourceEquipment = labState.equipment.find(e => e.id === sourceId || e.label === sourceId);
                const destinationEquipment = labState.equipment.find(e => e.id === destinationId || e.label === destinationId);
                if (!sourceEquipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• ngu·ªìn '${sourceId}'.` };
                if (!destinationEquipment) return { success: false, message: `Kh√¥ng t√¨m th·∫•y d·ª•ng c·ª• ƒë√≠ch '${destinationId}'.` };
                if (sourceEquipment.type !== 'balance') {
                    return { success: false, message: `Kh√¥ng th·ªÉ chuy·ªÉn ch·∫•t r·∫Øn t·ª´ '${sourceEquipment.label}' v√¨ ƒë√≥ kh√¥ng ph·∫£i l√† c√¢n.` };
                }
                if (destinationEquipment.type !== 'beaker' && destinationEquipment.type !== 'graduatedCylinder') {
                    return { success: false, message: `Kh√¥ng th·ªÉ chuy·ªÉn ch·∫•t r·∫Øn v√†o '${destinationEquipment.label}' v√¨ ƒë√≥ kh√¥ng ph·∫£i l√† d·ª•ng c·ª• ch·ª©a.` };
                }
                if (!sourceEquipment.chemicalOnPlate) return { success: false, message: `Kh√¥ng c√≥ ch·∫•t r·∫Øn n√†o tr√™n c√¢n '${sourceEquipment.label}'.` };
                const { name, mass } = sourceEquipment.chemicalOnPlate;
                destinationEquipment.contents.push({ name, quantity: mass, unit: 'g', form: 'solid', color: chemicalColors[name] || colorNameToRGBA['default'] });
                sourceEquipment.chemicalOnPlate = null;
                recalculateSolutionProperties(destinationEquipment);
                return { success: true, message: `ƒê√£ chuy·ªÉn ${mass}g ${name} t·ª´ ${sourceEquipment.label} v√†o ${destinationEquipment.label}.` };
            },
            weighSolid: async ({ equipmentId, chemical, mass }) => {
                const balance = labState.equipment.find(e => e.id === equipmentId || e.label === equipmentId);
                if (!balance || balance.type !== 'balance') return { success: false, message: `Kh√¥ng t√¨m th·∫•y c√¢n '${equipmentId}'.` };
                balance.chemicalOnPlate = { name: chemical, mass: 0 };
                await new Promise(resolve => {
                    const duration = 1500; const startTime = Date.now();
                    function loop() {
                        const progress = Math.min((Date.now() - startTime) / duration, 1);
                        balance.chemicalOnPlate.mass = mass * progress;
                        if (progress < 1) requestAnimationFrame(loop); else resolve();
                    }
                    requestAnimationFrame(loop);
                });
                balance.chemicalOnPlate.mass = mass;
                return { success: true, message: `ƒê√£ c√¢n ${mass}g ${chemical} tr√™n ${balance.label}.` };
            },
        };

        // --- AI MODEL DEFINITIONS AND API CALLERS ---
        const executorModel = getGenerativeModel(ai, {
            model: "gemini-2.0-flash",
            tools: [{ functionDeclarations: [
                { name: "researchChemical", description: "Tra c·ª©u th√¥ng tin c∆° b·∫£n v·ªÅ m·ªôt h√≥a ch·∫•t v√† hi·ªÉn th·ªã n√≥.", parameters: { type: "object", properties: { chemicalName: { type: "string" } }, required: ["chemicalName"] } },
                { name: "displayChemicalInfo", description: "Ch·ªâ d√πng ƒë·ªÉ hi·ªÉn th·ªã m·ªôt th·∫ª th√¥ng tin v·ªÅ h√≥a ch·∫•t ƒë√£ c√≥.", parameters: { type: "object", properties: { chemicalInfo: { type: "object" } }, required: ["chemicalInfo"] } },
                { name: "getNewEquipment", description: "L·∫•y m·ªôt d·ª•ng c·ª• m·ªõi.", parameters: { type: "object", properties: { type: { type: "string", enum: ["beaker", "balance", "graduatedCylinder"] }, label: { type: "string" }, capacity: { type: "number" } }, required: ["type", "label"] } },
                { name: "weighSolid", description: "C√¢n m·ªôt kh·ªëi l∆∞·ª£ng ch·∫•t r·∫Øn tr√™n m·ªôt c√°i c√¢n.", parameters: { type: "object", properties: { equipmentId: { type: "string" }, chemical: { type: "string" }, mass: { type: "number" } }, required: ["equipmentId", "chemical", "mass"] } },
                { name: "transferSolid", description: "Chuy·ªÉn ch·∫•t r·∫Øn t·ª´ c√¢n sang d·ª•ng c·ª• kh√°c.", parameters: { type: "object", properties: { sourceId: { type: "string" }, destinationId: { type: "string" } }, required: ["sourceId", "destinationId"] } },
                { name: "addChemical", description: "Th√™m m·ªôt h√≥a ch·∫•t v√†o m·ªôt d·ª•ng c·ª•.", parameters: { type: "object", properties: { equipmentId: { type: "string" }, name: { type: "string" }, form: { type: "string", enum: ["liquid", "solid"] }, quantity: { type: "number" }, unit: { type: "string", enum: ["ml", "g"] }, concentration: { type: "string" } }, required: ["equipmentId", "name", "form", "quantity", "unit"] } },
                { name: "transferLiquid", description: "Chuy·ªÉn ch·∫•t l·ªèng t·ª´ d·ª•ng c·ª• n√†y sang d·ª•ng c·ª• kh√°c.", parameters: { type: "object", properties: { sourceId: { type: "string" }, destinationId: { type: "string" }, quantity: { type: "number" } }, required: ["sourceId", "destinationId", "quantity"] } },
                { name: "stir", description: "Khu·∫•y dung d·ªãch.", parameters: { type: "object", properties: { equipmentId: { type: "string" }, duration_seconds: { type: "number" } }, required: ["equipmentId", "duration_seconds"] } },
                { name: "showReactionEffect", description: "Hi·ªÉn th·ªã hi·ªáu ·ª©ng ph·∫£n ·ª©ng.", parameters: { type: "object", properties: { effect: { type: "string", enum: ["precipitate", "fizzing"] }, productName: { type: "string" }, equipmentId: { type: "string" } }, required: ["effect", "productName", "equipmentId"] } },
                { name: "createEquipmentFromDrawings", description: "Bi·∫øn c√°c h√¨nh ƒë√£ v·∫Ω th√†nh d·ª•ng c·ª• h√≥a h·ªçc.", parameters: { type: "object", properties: { objects: { type: "array", items: { type: "object", properties: { drawingIndex: { type: "number" }, label: { type: "string" }, type: { type: "string", "enum": ["beaker", "graduatedCylinder"] }, capacity: {type: "number"} }, required: ["drawingIndex", "label", "type"] } } } } },
            ] }],
            systemInstruction: "B·∫°n l√† m·ªôt AI th·ª±c thi trong ph√≤ng th√≠ nghi·ªám ·∫£o. Nhi·ªám v·ª• c·ªßa b·∫°n l√† th·ª±c hi·ªán c√°c y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng b·∫±ng c√°ch g·ªçi c√°c c√¥ng c·ª• (h√†m) c√≥ s·∫µn. QUY TR√åNH QUAN TR·ªåNG: 1. ƒê·ªÉ 'c√¢n' m·ªôt ch·∫•t r·∫Øn, b·∫°n B·∫ÆT BU·ªòC ph·∫£i d√πng `weighSolid` ƒë·ªÉ ƒë·∫∑t ch·∫•t ƒë√≥ l√™n m·ªôt c√°i c√¢n. 2. Sau khi c√¢n, n·∫øu ng∆∞·ªùi d√πng y√™u c·∫ßu 'cho v√†o' ho·∫∑c 'chuy·ªÉn', b·∫°n m·ªõi d√πng `transferSolid`. 3. N·∫øu ng∆∞·ªùi d√πng ƒë√£ v·∫Ω h√¨nh, b·∫°n PH·∫¢I ∆∞u ti√™n g·ªçi h√†m `createEquipmentFromDrawings` ƒë·ªÉ bi·∫øn c√°c h√¨nh v·∫Ω ƒë√≥ th√†nh d·ª•ng c·ª•."
        });

        const plannerModel = getGenerativeModel(ai, {
            model: "gemini-2.0-flash",
            tools: [{ functionDeclarations: [ { name: "finalizeExperiment", description: "T·ªïng k·∫øt cu·ªôc th·∫£o lu·∫≠n v√† tr√≠ch xu·∫•t ra m·ªôt k·∫ø ho·∫°ch c√°c b∆∞·ªõc th√≠ nghi·ªám ƒë·ªÉ th·ª±c thi.", parameters: { type: "object", properties: { steps: { type: "array", description: "M·ªôt m·∫£ng c√°c b∆∞·ªõc h√†nh ƒë·ªông.", items: { type: "object", properties: { description: { type: "string", description: "M√¥ t·∫£ b∆∞·ªõc b·∫±ng ng√¥n ng·ªØ t·ª± nhi√™n." }, prompt: { type: "string", description: "L·ªánh ch√≠nh x√°c ƒë·ªÉ ng∆∞·ªùi d√πng g·ª≠i cho AI Th·ª±c thi." } } } } }, required: ["steps"] } } ] }],
            systemInstruction: "B·∫°n l√† m·ªôt tr·ª£ l√Ω h√≥a h·ªçc th√¥ng th√°i. Nhi·ªám v·ª• c·ªßa b·∫°n l√† th·∫£o lu·∫≠n v√† l√™n k·∫ø ho·∫°ch th√≠ nghi·ªám c√πng ng∆∞·ªùi d√πng. H√£y s·ª≠ d·ª•ng ƒë·ªãnh d·∫°ng Markdown. Khi ng∆∞·ªùi d√πng y√™u c·∫ßu, h√£y s·ª≠ d·ª•ng c√¥ng c·ª• 'finalizeExperiment' ƒë·ªÉ t·ªïng k·∫øt k·∫ø ho·∫°ch."
        });
        let assistantChat;
        function openSuggestionModal() {
            dom.suggestionModal.style.display = 'flex';
            assistantChat = plannerModel.startChat();
        }
        function closeSuggestionModal() { dom.suggestionModal.style.display = 'none'; }

        async function callExecutorAPI(promptText) {
            if (!promptText && finalizedDrawings.length === 0) return;
            const allButtons = [dom.sendPromptButton, dom.startReactionButton, dom.suggestionButton, dom.resetButton];
            allButtons.forEach(btn => { btn.disabled = true; });
            dom.buttonText.classList.add('hidden');
            dom.buttonSpinner.classList.remove('hidden');
            logAction('user-request', `<strong>USER:</strong> ${promptText}`);

            try {
                let fullPrompt = promptText;
                if (finalizedDrawings.length > 0) {
                    let drawingContext = `B·ªëi c·∫£nh: Ng∆∞·ªùi d√πng ƒë√£ v·∫Ω ${finalizedDrawings.length} h√¨nh. H√£y ph√¢n t√≠ch c√°c h√¨nh v·∫Ω n√†y v√† y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng.`;
                    fullPrompt = `${drawingContext}\n\nY√™u c·∫ßu: ${promptText}`;
                }
                
                if (!executorChat) {
                    executorChat = executorModel.startChat();
                }
                
                let result = await executorChat.sendMessage(fullPrompt);
                
                while (true) {
                    const functionCalls = (result && result.response && typeof result.response.functionCalls === 'function') ? result.response.functionCalls() : null;
                    if (!functionCalls || functionCalls.length === 0) {
                        const responseText = (result && result.response && typeof result.response.text === 'function') ? result.response.text() : "ƒê√£ ho√†n th√†nh.";
                        logAction('ai-response', `<strong>GEMINI:</strong> ${responseText}`);
                        break; 
                    }
                    
                    logAction('function-call', `<strong>GEMINI:</strong> Y√™u c·∫ßu g·ªçi [${functionCalls.map(fc => `${fc.name}(${JSON.stringify(fc.args)})`).join(', ')}]`);
                    
                    const toolParts = [];
                    for (const call of functionCalls) {
                        const func = availableFunctions[call.name];
                        if (func) {
                            const funcResult = await func(call.args);
                            toolParts.push({ functionResponse: { name: call.name, response: funcResult } });
                        }
                    }
                    logAction('function-result', `<strong>APP:</strong> ƒê√£ ch·∫°y h√†m, g·ª≠i l·∫°i k·∫øt qu·∫£.`);
                    result = await executorChat.sendMessage(toolParts);
                }
                const planSteps = document.querySelectorAll('.plan-step-item');
                planSteps.forEach(step => {
                    if (step.dataset.prompt === promptText.trim() && !step.classList.contains('completed')) {
                        step.classList.add('completed');
                    }
                });

            } catch (error) {
                console.error("Executor API Error:", error);
                logAction('error', `<strong>L·ªói:</strong> ${error.message}.`);
            } finally {
                allButtons.forEach(btn => { btn.disabled = false; });
                dom.buttonText.classList.remove('hidden');
                dom.buttonSpinner.classList.add('hidden');
            }
        }
        
        async function handleStartReaction() {
            const reactionBeaker = labState.equipment.find(e => e.type === 'beaker' && e.contents.filter(c => c.form === 'liquid' || c.form === 'solid').length > 1);
            if (!reactionBeaker) {
                logAction('system', '<strong>APP:</strong> Kh√¥ng t√¨m th·∫•y c·ªëc n√†o ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ ph·∫£n ·ª©ng.');
                return;
            }

            const allButtons = [dom.sendPromptButton, dom.startReactionButton, dom.suggestionButton, dom.resetButton];
            allButtons.forEach(btn => { btn.disabled = true; });
            dom.reactionBtnText.classList.add('hidden');
            dom.reactionBtnSpinner.classList.remove('hidden');
            
            const reactantNames = reactionBeaker.contents.map(c => c.name.replace(' (h√≤a tan)', '')).join(' v√† ');
            logAction('user-request', `<strong>USER (auto):</strong> B·∫Øt ƒë·∫ßu ph·∫£n ·ª©ng gi·ªØa ${reactantNames} trong '${reactionBeaker.label}'.`);

            try {
                const predictionModel = getGenerativeModel(ai, { model: "gemini-2.0-flash" });
                const prompt = `M√¥ t·∫£ ng·∫Øn g·ªçn s·∫£n ph·∫©m ch√≠nh v√† hi·ªán t∆∞·ª£ng quan s√°t ƒë∆∞·ª£c (k·∫øt t·ªßa, s·ªßi b·ªçt kh√≠, ƒë·ªïi m√†u) khi cho ${reactantNames} ph·∫£n ·ª©ng v·ªõi nhau. Ch·ªâ tr·∫£ l·ªùi v·ªõi ƒë·ªãnh d·∫°ng JSON: {"productName": "T√™n s·∫£n ph·∫©m", "phenomenon": "precipitate" | "fizzing" | "colorChange", "details": "m√¥ t·∫£ ng·∫Øn, v√≠ d·ª•: 'tr·∫Øng', 'kh√¥ng m√†u', 'xanh lam'"}. N·∫øu kh√¥ng c√≥ ph·∫£n ·ª©ng, tr·∫£ v·ªÅ {"phenomenon": "none"}.`;
                
                const result = await predictionModel.generateContent(prompt);
                const textResponse = result.response.text();
                const jsonString = textResponse.match(/{.*}/s)[0];
                const reactionData = JSON.parse(jsonString);

                logAction('ai-response', `<strong>GEMINI (d·ª± ƒëo√°n):</strong> Ph·∫£n ·ª©ng t·∫°o ra ${reactionData.productName} v·ªõi hi·ªán t∆∞·ª£ng ${reactionData.phenomenon}.`);

                if (reactionData.phenomenon === 'precipitate') {
                    if (reactionData.productName && !chemicalColors[reactionData.productName]) {
                        await availableFunctions.researchChemical({ chemicalName: reactionData.productName });
                    }
                    await availableFunctions.showReactionEffect({ effect: 'precipitate', productName: reactionData.productName, equipmentId: reactionBeaker.label });
                    reactionBeaker.contents.push({ name: reactionData.productName, form: 'solid', isPrecipitate: true, color: chemicalColors[reactionData.productName] || colorNameToRGBA['default'] });
                } else if (reactionData.phenomenon === 'fizzing') {
                    await availableFunctions.showReactionEffect({ effect: 'fizzing', productName: reactionData.productName, equipmentId: reactionBeaker.label });
                } else if (reactionData.phenomenon === 'colorChange') {
                    await availableFunctions.changeSolutionColor({ equipmentId: reactionBeaker.label, newColorName: reactionData.details });
                } else {
                    logAction('system', '<strong>APP:</strong> Kh√¥ng c√≥ ph·∫£n ·ª©ng n√†o x·∫£y ra.');
                }

            } catch (error) {
                console.error("Reaction Prediction Error:", error);
                logAction('error', `<strong>L·ªói:</strong> Kh√¥ng th·ªÉ d·ª± ƒëo√°n ph·∫£n ·ª©ng. ${error.message}`);
            } finally {
                allButtons.forEach(btn => { btn.disabled = false; });
                dom.reactionBtnText.classList.remove('hidden');
                dom.reactionBtnSpinner.classList.add('hidden');
            }
        }

        function appendAssistantMessage(sender, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `assistant-chat-message ${sender}`;
            messageDiv.innerHTML = marked.parse(text);
            dom.assistantChatHistory.appendChild(messageDiv);
            dom.assistantChatHistory.scrollTop = dom.assistantChatHistory.scrollHeight;
        }

        async function sendAssistantMessage() {
            const userPrompt = dom.assistantPromptInput.value.trim();
            if (!userPrompt || !assistantChat) return;

            dom.assistantPromptInput.disabled = true;
            dom.assistantSendButton.disabled = true;
            appendAssistantMessage('user', userPrompt);
            dom.assistantPromptInput.value = '';

            try {
                let result = await assistantChat.sendMessage(userPrompt);

                while (true) {
                    const functionCalls = (result && result.response && typeof result.response.functionCalls === 'function') ? result.response.functionCalls() : null;
                    
                    if (!functionCalls || functionCalls.length === 0) {
                        const responseText = (result && result.response && typeof result.response.text === 'function') ? result.response.text() : "Xin l·ªói, t√¥i kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu n√†y.";
                        appendAssistantMessage('assistant', responseText);
                        break;
                    }

                    const toolParts = [];
                    for (const call of functionCalls) {
                        const func = availableFunctions[call.name];
                        if (func) {
                            const funcResult = await func(call.args);
                            if (call.name === 'finalizeExperiment') {
                                appendAssistantMessage('assistant', "Tuy·ªát v·ªùi! K·∫ø ho·∫°ch ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ra m√†n h√¨nh ch√≠nh. B·∫°n c√≥ th·ªÉ ƒë√≥ng c·ª≠a s·ªï n√†y v√† b·∫Øt ƒë·∫ßu th·ª±c hi·ªán t·ª´ng b∆∞·ªõc.");
                                return;
                            }
                            toolParts.push({ functionResponse: { name: call.name, response: funcResult } });
                        }
                    }
                    result = await assistantChat.sendMessage(toolParts);
                }
            } catch (error) {
                console.error("Planner API Error:", error);
                appendAssistantMessage('assistant', `ƒê√£ x·∫£y ra l·ªói: ${error.message}`);
            } finally {
                dom.assistantPromptInput.disabled = false;
                dom.assistantSendButton.disabled = false;
                dom.assistantPromptInput.focus();
            }
        }
        
        // --- QU·∫¢N L√ù SCENE (L∆ØU/T·∫¢I TH√ç NGHI·ªÜM) ---
        const SCENE_STORAGE_KEY = 'chemistry_lab_scenes_v1';

        function getSavedScenes() { return JSON.parse(localStorage.getItem(SCENE_STORAGE_KEY) || '{}'); }
        
        function saveCurrentScene() {
            const sceneName = dom.sceneNameInput.value.trim();
            if (!sceneName) { 
                showConfirmationModal('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n th√≠ nghi·ªám!', () => {}, true);
                return;
             }
            const scenes = getSavedScenes();
            scenes[sceneName] = {
                state: labState,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(SCENE_STORAGE_KEY, JSON.stringify(scenes));
            dom.sceneNameInput.value = '';
            populateScenesList();
            showToast(`ƒê√£ l∆∞u th√≠ nghi·ªám '${sceneName}'.`, 'system');
        }

        function loadScene(sceneName) {
            const sceneData = getSavedScenes()[sceneName];
            if (!sceneData) return;
            labState = JSON.parse(JSON.stringify(sceneData.state));
            dom.sceneManagerModal.classList.add('hidden');
            logAction('system', `<strong>APP:</strong> ƒê√£ t·∫£i th√≠ nghi·ªám '${sceneName}'.`);
        }

        function deleteScene(sceneName) {
            const scenes = getSavedScenes();
            delete scenes[sceneName];
            localStorage.setItem(SCENE_STORAGE_KEY, JSON.stringify(scenes));
            populateScenesList();
        }

        function populateScenesList() {
            const scenes = getSavedScenes();
            dom.savedScenesList.innerHTML = '';
            if (Object.keys(scenes).length === 0) {
                dom.savedScenesList.innerHTML = `<p class="text-slate-500 text-center p-4">Ch∆∞a c√≥ th√≠ nghi·ªám n√†o ƒë∆∞·ª£c l∆∞u.</p>`;
                return;
            }
            for (const name in scenes) {
                const sceneEl = document.createElement('div');
                sceneEl.className = 'flex justify-between items-center p-3 bg-slate-800/70 rounded-lg';
                sceneEl.innerHTML = `
                    <div>
                        <p class="font-semibold text-white">${name}</p>
                        <p class="text-xs text-slate-400">ƒê√£ l∆∞u: ${new Date(scenes[name].timestamp).toLocaleString()}</p>
                    </div>
                    <div class="flex gap-2">
                        <button class="load-btn btn p-2 bg-primary rounded-md" data-name="${name}" title="T·∫£i"><i data-lucide="download" class="w-4 h-4 text-white pointer-events-none"></i></button>
                        <button class="delete-btn btn p-2 bg-red-600 rounded-md" data-name="${name}" title="X√≥a"><i data-lucide="trash-2" class="w-4 h-4 text-white pointer-events-none"></i></button>
                    </div>
                `;
                dom.savedScenesList.appendChild(sceneEl);
            }
            lucide.createIcons();
        }
        
        // --- LOGIC C√ÅC MODAL ---
        let confirmCallback = null;
        function showConfirmationModal(title, message, onConfirm, isAlert = false) {
            dom.confirmationTitle.textContent = title;
            dom.confirmationMessage.textContent = message;
            confirmCallback = onConfirm;
            dom.confirmCancelButton.classList.toggle('hidden', isAlert);
            dom.confirmActionButton.textContent = isAlert ? 'OK' : 'X√°c nh·∫≠n';
            dom.confirmationModal.classList.remove('hidden');
        }
        function hideConfirmationModal() { dom.confirmationModal.classList.add('hidden'); confirmCallback = null; }
        
        // --- LOGIC C√îNG C·ª§ V·∫º ---
        function startDraw(event) {
            if (!activeDrawTool) return;
            isDrawing = true;
            drawStartPoint = { x: event.offsetX, y: event.offsetY };
            currentDrawing = { type: activeDrawTool };
            if (activeDrawTool === 'freeform') currentDrawing.path = [drawStartPoint];
        }
        function draw(event) {
            if (!isDrawing || !drawStartPoint) return;
            const currentPoint = { x: event.offsetX, y: event.offsetY };
            switch (activeDrawTool) {
                case 'freeform': currentDrawing.path.push(currentPoint); break;
                case 'box':
                    currentDrawing.x = Math.min(drawStartPoint.x, currentPoint.x);
                    currentDrawing.y = Math.min(drawStartPoint.y, currentPoint.y);
                    currentDrawing.w = Math.abs(drawStartPoint.x - currentPoint.x);
                    currentDrawing.h = Math.abs(drawStartPoint.y - currentPoint.y);
                    break;
            }
        }
        function endDraw() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentDrawing.type === 'box' && (!currentDrawing.w || currentDrawing.w < 5 || !currentDrawing.h || currentDrawing.h < 5)) {
                currentDrawing = {}; return;
            }
            finalizedDrawings.push({ ...currentDrawing });
            currentDrawing = {};
        }
        function toggleDrawTool(tool) {
            if (activeDrawTool) {
                document.querySelector(`.draw-tool[data-tool="${activeDrawTool}"]`)?.classList.remove('active');
                dom.canvas.classList.remove('drawing-mode');
            }
            if (activeDrawTool === tool) {
                activeDrawTool = null;
                return;
            }
            activeDrawTool = tool;
            document.querySelector(`.draw-tool[data-tool="${tool}"]`)?.classList.add('active');
            dom.canvas.classList.add('drawing-mode');
        }
        function clearAllDrawings() {
            finalizedDrawings = [];
            currentDrawing = {};
        }

        // --- G·∫ÆN K·∫æT S·ª∞ KI·ªÜN V√Ä KH·ªûI T·∫†O ---
        dom.sendPromptButton.addEventListener("click", () => callExecutorAPI(dom.promptInput.value.trim()));
        dom.promptInput.addEventListener("keydown", (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); dom.sendPromptButton.click(); }
        });
        dom.startReactionButton.addEventListener("click", handleStartReaction);
        dom.resetButton.addEventListener("click", () => {
             showConfirmationModal('D·ªçn d·∫πp Ph√≤ng th√≠ nghi·ªám?', 'H√†nh ƒë·ªông n√†y s·∫Ω x√≥a t·∫•t c·∫£ d·ª•ng c·ª• v√† ti·∫øn tr√¨nh. B·∫°n c√≥ ch·∫Øc ch·∫Øn?', () => {
                availableFunctions.resetLab();
                logAction('system', '<strong>APP:</strong> Ph√≤ng th√≠ nghi·ªám ƒë√£ ƒë∆∞·ª£c d·ªçn d·∫πp.');
            });
        });
        
        dom.openSidebarButton.addEventListener('click', () => { dom.leftSidebar.classList.add('open'); dom.sidebarBackdrop.classList.remove('hidden'); });
        function closeSidebar() { dom.leftSidebar.classList.remove('open'); dom.sidebarBackdrop.classList.add('hidden'); }
        dom.sidebarBackdrop.addEventListener('click', closeSidebar);
        dom.togglePanelButton.addEventListener('click', () => {
            dom.bottomPanel.classList.toggle('translate-y-[calc(100%-4rem)]');
            dom.toggleIcon.classList.toggle('rotate-180');
        });
        dom.suggestionButton.addEventListener("click", openSuggestionModal);
        dom.closeSuggestionModal.addEventListener("click", closeSuggestionModal);
        dom.assistantSendButton.addEventListener("click", sendAssistantMessage);
        dom.assistantPromptInput.addEventListener("keypress", (e) => {
            if (e.key === 'Enter') { e.preventDefault(); sendAssistantMessage(); }
        });
        dom.openTutorialButton.addEventListener('click', () => dom.tutorialModal.classList.remove('hidden'));
        dom.closeTutorialButton.addEventListener('click', () => dom.tutorialModal.classList.add('hidden'));
        dom.confirmCancelButton.addEventListener('click', hideConfirmationModal);
        dom.confirmActionButton.addEventListener('click', () => { if (confirmCallback) confirmCallback(); hideConfirmationModal(); });
        
        dom.openSceneManager.addEventListener('click', () => { populateScenesList(); dom.sceneManagerModal.classList.remove('hidden'); });
        dom.closeSceneManager.addEventListener('click', () => dom.sceneManagerModal.classList.add('hidden'));
        dom.saveSceneButton.addEventListener('click', saveCurrentScene);
        dom.savedScenesList.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            const sceneName = target.dataset.name;
            if (target.classList.contains('load-btn')) {
                loadScene(sceneName);
            } else if (target.classList.contains('delete-btn')) {
                showConfirmationModal('X√≥a Th√≠ nghi·ªám?', `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a vƒ©nh vi·ªÖn th√≠ nghi·ªám "${sceneName}" kh√¥ng?`, () => deleteScene(sceneName));
            }
        });

        dom.actionLog.addEventListener('click', (e) => {
            if (e.target.classList.contains('equipment-label')) {
                const label = e.target.dataset.label;
                const equipment = labState.equipment.find(eq => eq.label === label);
                if (equipment) {
                    equipment.isHighlighted = true;
                    setTimeout(() => {
                        equipment.isHighlighted = false;
                    }, 1000);
                }
            }
        });

        dom.drawTools.forEach(button => button.addEventListener('click', () => toggleDrawTool(button.dataset.tool)));
        dom.clearDrawingsButton.addEventListener('click', clearAllDrawings);

        window.onload = () => {
            drawLab();
            lucide.createIcons();
        };
    </script>
</body>
</html>
